'''
youtube url -> https://www.youtube.com/watch?v=5Lu34WIx2Us&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC&index=6&t=22s

동적 계획법(Dynamic Programming)

>> Concept
메모리를 적절히 사용하여 수행 시간 효율성일 향상시키는 방법
이미 게산된 결과(작은 문제)는 별도의 메모리 영영에 저장하여 다시 계산
2가지(탑다운, 바텀업)으로 구성

>> 메모이제이션(Memoization) 
한 번 계산한 결과를 메모리 공간에 저장하는 기법

>> 조건
다음의 2가지 조건을 만족할 때 사용 가능 

1. 최적 부분 구조(Optimal Substructure)
큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아 큰 문제를 해결 가능
2. 중복 부분 문제(Overlapping Subproblem)
동일한 작은 문제를 반복적으로 해결

>> 접근방법
문제의 유형이 다이나믹 프로그래밍 유형임을 파악하는 것이 중요!
먼저 다른 아이디어로 해결할 수 있나 생각해보고 그 이후 필요 조건(2가지)에 대해 고려해보기
유형만 파악하면 쉽게 풀 수 있도록 출제되는 경우가 많음!

>> 분할 정복과 차이점
최적 부분 구조임은 공통점이지만 중복 부분 문제임이 다름
- 동적 할당 : 작은 중복된 문제로 나뉨
- 분할 정복 : 한 번 계산된 값은 중복처리 하지 않음

>> 용어
점화식 = 인접한 항들 사이의 관계식
dp 테이블 = 작은 문제의 결과를 담아 놓는 테이블(배열, 리스트)

>> 문제(피보나치 수열)

점화식 = an = an-1 + an-2, a1= 1, a2 = 2

1. 최적 부분 구조 만족하느냐?
d5 = d4 + d3    -> d5는 d4와 d3의 합으로 구할 수 있음
2. 중복 부분 구조 만족하느냐
d4 = d3 + d2, d3 = d2 + d1 => 반복됨

'''

# 탑다운
d = [0] * 100


def fibo(x):
    if x == 1 or x == 2:
        return 1

    if d[x] != 0:
        return d[x]

    d[x] = fibo(x-1) + fibo(x-2)

    return d[x]


print(fibo(99))

# 바텀업
d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n+1):
    d[i] = d[i-1] + d[i-2]

print(d[99])
