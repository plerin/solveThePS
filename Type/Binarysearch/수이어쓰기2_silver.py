'''
backjoon url -> https://www.acmicpc.net/problem/1790

>> Keyword
범위가 1억이상 => 이진탐색 or 규칙을 통해 빠른 계산법이 있을거라 예상
패턴 = 자리수에 따라 9*1, 90*2, 900*3 순으로 길어진다(누적하며 진행)

1. k가 속한 자리수를 구한다
    k가 9*10**(자리수-1) * 자리수 보다 클 경우 반복하며 ans값 누적
2. k번째 값이 있는 수를 구한다
    ans = (ans+1) + (k-1) // digit -> k가 속한 수를 구하기
3. n과 비교하고 k번째 값을 반환 
    if ans > n then print(-1) else print(str(ans)[(k-1)%digit])

>> P
1부터 N까지 수를 이어서 쓰면 수를 얻을 수 있다.
앞에서 k번째 자리 숫자 어떤 수인지 구하는 프로그램 작성
    - 범위 -> N ~ 1억, k ~ 10억

>> S
범위가 크기 때문에 이진탐색이 필요

접근
정말 똑독한 사람의 풀이를 갖고왔어 쉽고 간결해 

1. k가 1~9 범위 안에 있다면 자리수는 한자리, 10~99 범위라면 자리수는 두자리
-> k는 자리수에 따라 9*1, 90*2, 900*3 을 빼준다
왜냐하면 1~9는 1개, 10~99는 90개이지만 두자리수니까 *2, 100~999는 900개지만 세자리수니까 *3 ..

2. k에서 자리수에 맞게 빼주다보면 더이상 뺄 수 없는 값(k번째의 자리수를 구할 수 있음)
이제 ans를 구하는데(k번째의 값)
1번 과정에서 빼준 값을 ans에 더해주고 
ans = (ans+1) + (k-1) // digit ==> k번재의 값을 구할 수 있어
왜냐하면, ans는 9 or 99 or 999와 같이 10의 배수에서 1 부족한 값이므로 k에서 1을 ans로 준다

3. 범위(n)와 비교
구하고자 하는 값(ans)이 n보다 크면 범위를 벗어나니까 print(-1)
아니면 str로 변환해서 [(k-1)%digit] 값을 반환
'''


n, k = map(int, input().split())

# ans = k번째 갑이 속하는 수를 구하기 위함
ans = 0
digit = 1
nine = 9

# 9*1, 90*2, 900*3 을 간단하게 표현
while k > nine * digit:
    k -= nine * digit
    ans += nine     # 이전 자리수만 유지
    digit += 1
    nine *= 10

# ans가 99면 -> 3의자리 숫자 -> k와 연산을 통해 k번째 값이 있는 수를 구함
ans = (ans+1) + (k-1) // digit

if ans > n:
    print(-1)
else:
    print(str(ans)[(k-1) % digit])
