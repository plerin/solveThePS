'''
>> P
1~N까지 수를 한 번식 이용해서 
가장 긴 증가 부분 수열 길이(M), 가장 긴 감소 부분 수열 길이(K)인 수열 출력
    - 조건을 만족하는 수열이 없다면 -1 출력
    - 숫자를 모두 한 번씩 사용!
>> S
문제의 접근을 너무 잘했고 후회 안해
30분 이상 문제를 풀었고 다른 사람의 풀이를 보는거니까 그것도.
이제 내가 할 일은 이 문제의 풀이를 이해하고! 풀어보고! 다시 스스로 풀어보는것!
분명 나중에 풀면 다시 못풀텐데 괜찮아 원래 까먹는거야 자신감 떨어질 필요없이 
당연한 것 그렇게 조금씩 성장하는 것!

가장 긴 증가하는 부분 수열 / 가장 긴 감소하는 부분 수열을 구분하는 게 필요!!!
1. N의 범위 _ M + K - 1 <= N <= M * K
    - M + K - 1 : 증가, 감소 수열이 한번씩 나와야하기 때문(M+K), 두 수열이 하나의 숫자 공유함(-1)
    - M * K : ex) M =3 / N =4 라고 할 때 숫자를 채워보면
        -> 4321 8765 1211109으로 3그룹(최대 증가수열 4, 8, 12) & (감소 수열 4321, 8765, 3211019)
        여기서 M*K가 N보다 크면 증가/감소 수열이 늘어나(12의 범위를 벗어나)
2. 풀이 방법
    1) A = []로 두고 먼저 k만큼 내림차순으로 A에 추가
    2) N개중 k개 사용했으므로 N -= k _ N = 앞으로 사용가능 개수
    3) M -= 1 _ 이미 한 행을 만들었기 때문에
    4) 이제 n과m을 0으로 만들면 된다 -> 모든 수를 사용하기 때문에
    5) N//M이 다음 만들 행의 원소 개수
    6) A.extend(range(k+n//m, k, -1)) -> k는 깔아두고 n//m만큼 내림차순으로 추가(행)
    7) k & n 모두 n//m 사용한 만큼 갱신 & m -= 1 한 행 만들었으니
    8 반복문 끝나고 A출력
'''


def solve(n: int, m: int, k: int) -> str:
    seq = []

    if n < (m+k-1) or n > (m*k):  # 조건 불만족 => 최소(증가수열+감소수열-중복값(1)) or 최대(증가수열*감소수열)
        return '-1'
    else:
        seq = [str(i) for i in range(k, 0, -1)]  # 리스트 초기 값을 1~K 내림차순 정렬
        n -= k  # 사용 가능 숫자 - 사용한 수(K개)
        m -= 1  # 만들어야 하는 쌍(행)

        while m:
            # 한 행 만들 때 필요한 수 개수 n//m => m개 만들어야 하니가(증가 수열 때문에)
            # 행을 만들 때마다 k는 점점 커짐 == 내림차순
            seq.extend([str(i) for i in range(k+(n//m), k, -1)])
            k += (n//m)
            n -= (n//m)
            m -= 1

        return ' '.join(seq)


# 입력 받기
N, M, K = map(int, input().split())

print(solve(N, M, K))
