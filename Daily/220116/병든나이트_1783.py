'''
>> P
N * M 체스판에서 (N-1,0)에 있는 나이트가 방문할 수 있는 최대 칸의 개수
    - 이동 제한 : (2, 1), (1, 2), (-1, 2), (-2, 1)
    - 이동 횟수가 4번보다 작은 경우 이동 제약이 없다
    - 이동 횟수가 4번 이상인 경우 모든 이동방법을 한 번식 사용해야 함
    - N과 M의 범위는 20억보다 작거나 같은 자연수
>> S
문제를 이제야 이해 했어
이동 횟수가 4번 미만인 경우와 4번 이상인 경우
    - 4번 미만 : 이동 방법 중 어떠한 걸 사용해도 상관없어
    - 4번 이상 : 무조건 이동 방법 4가지를 한 번 사용해야해 
        e) 1,2,3,4 번 사용한 뒤에는 어떤 걸 사용해도 됨!!!!!!!

이동 횟수가 4번보다 적은 경우와 4번 이상인 경우를 분리하여 문제 해결
체스판 최소 크기는 3*7
1) N == 1인 경우
    - 이동 불가 == 방문 가능 칸 1
2) N == 2인 경우
    - 위아래로 한 칸씩 이동 가능, 가로로 2칸씩 몇 번 이동한 지 계산하기
    - 최대 값은 3(4부터 모든 이동을 사용해야하기때문에), (M-1) // 2 (첫 칸 제외하고 이동은 모두 2칸이기 때문에)
    -> min(3, (M-1)// 2) 인데 방문 가능 칸 == 이동 횟수 + 1이니까
    -> min(4, (M-1) // 2 + 1)
3) N >= 3 and M < 7인 경우
    - 세로로 제약이 없으니 최대 값은 가로로 한 칸씩 가는 연산
    - 최대 값은 3(4번부터 모든 이동 해야하므로(M최소 7))
    - min(4, M) --> min(3, M-1)인데 이동 횟수 + 1이니가
4) N >= 3 and M >= 7인 경우
    - 4번 이동최소단위 이상이니까 모두 가능
    - 최대 이동은 세로+=2, 가로+=1 인데 모든 이동 방향 1회는 사용해야하니가
    - 가로+=2를 한 번씩 써줘야함
    - 2 + (M-5) + 1 _ 가로 1연산 2번(2), 가로 2 연산 2번(4) & 처음 자리(1) 을 
    -> (M-5) ==> 5(가로 2연산 2번 + 처음 좌표)
    -> 2 ==> (가로 연산 2번)
    -> + 1 ==> 좌표 == 이동횟수 + 1 
'''

N, M = map(int, input().split())

if N == 1:
    print(1)
elif N == 2:
    print(min(4, (M-1)//2 + 1))
elif M < 7:
    print(min(4, M))
else:
    print(2 + (M-5) + 1)
