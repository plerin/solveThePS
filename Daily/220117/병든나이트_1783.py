'''
>> P
N*M 체스판에서 정해진 이동 규칙이 있는 병든 나이트가 방문할 수 있는 칸의 최대 개수 구하라
    - 방법 : (-2 ,1), (-1, 2), (1, 2), (2, 1) __ 오른쪽으로만 이동
    - 제약 :
        1) 이동 횟수가 4번보다 적지 않으면 이동 방법 모두 한번씩 사용(이동횟수 >= 4)
        2) 이동 횟수가 4번보다 적으면 이동 제약없음(이동횟수 < 4)
    - 범위 : ~20억
>> S
방문가능 칸 = 이동 횟수 + 1 ( + 1 == 처음 있던 위치)
이동 횟수가 4번 미만 일 때와 이상일 때로 나누어 볼 수 있다.
모든 이동 방향으로 1번씩 이동했을 때 필요한 최소 칸은 3*7!

1) N == 1
이동 못해 ==> 이동(0) + 방문(1) == 1
2) N == 2 
2/3 방법으로만 이동 가능(세로+-1, 가로+2)
하지만 최대 이동 횟수 제한은 3(4번 이동부터 모든 방법을 사용해야하는데 세로 2칸 이동을 못하기 때문)
min(3, (M-1)//2) -> min(4, (M-1)//2 + 1) // 방문 칸 == 이동 횟수 + 1
3) M < 7
N이 3이상이며 M이 7 미만인 경우(모든 방향 1번 이동 충족 x)
최대 이동 횟수 제한은 3(M이 7이 안되면 모든 방향 움직일 수 없기 때문)
3번 이동한다고 했을 때 최대 횟수는 (세로+-2, 가로+1)가는 경우
min(3, (M-1)) -> min(4, M)
4) else
N>=3 and M>=7 인경우 == 최대 이동 제한 걸 필요 없음
2 + (M-5) -> 가로 2이동(2번) + (M - 초기 위치 + 가로 2이동2번 == 4) 

>> 소감
문제 등급만 보고 믿으면 안됨(내 기준 실버 4문제가 아니야)
문제를 이해하는 것도 다른 풀이를 보고 이해하는 것 모두 어려웠어
이동 횟수가 4번보다 적지 않다면 / 이동 횟수가 4번보다 적은 경우
    == 이동 횟수 >= 4 and 이동 횟수 < 4 인데 이것부터 이해 어려웠고
모든 이동 횟수를 1번 이용한다
    - 지금까지 2차원 배열에서 문제 접근 방법은 한 좌표로 이동후에 모든 경우의 수(상/하/좌/우)로 이동 후 다시 그 위치에서 이동한다 였는데
    - 이 문제는 오히려 2차원이 살짝 가미된 1차원 배열 문제처럼 위/아래보다(최소 조건 충족여부만 확인) 오른쪽으로 얼마나 가는지가 중요했어
    - 모든 이동 경우를 사용하려면 최소 '3*7'이고 이걸 통해 문제 풀이를 도출해야 함
N이 x인 경우 M가 y인 경우
    - N가 1일 때 2일때 3이상일 때
    - M이 7미만일 때 7이상일 때 를 나눠서 풀이함

게임같은 문제야 지금까지 획일적으로 풀이했던 문제와 달리
1. 횟수에 따른 제약을 확인
2. 모든 경우 이동 시 최소 필요한 '3*7'임을 확인
3. N과 M의 값에 따라 규칙 확인 후 출력
    - 최대 경우(3)을 구하고 구하기 위한 값과 비교하기
'''

N, M = map(int, input().split())

if N == 1:
    print(1)
elif N == 2:
    print(min(4, (M-1)//2 + 1))
elif M < 7:
    print(min(4, M))
else:
    print(2 + (M-5) + 1)
