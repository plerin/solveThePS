'''
>> P
N개 회의가 있고 각 회의에는 시작 / 끝 시간이 주어진다. 
이 때 회의를 가장 많이 할 수 있는 개수를 구하라
    - 회의 개수는 ~ 10만 / 시간은 2**31-1 
        -> 개수와 범위가 굉장히 크다 -> 효율적인 풀이 필요
>> S
그리디 알고리즘 문제는 조건에서 효율적인 방법을 찾아서 코드로 구현하는 것 
회의 시작 / 끝 시간이 주어질 때 완전탐색이 아닌 효율적인 방법으로 뽑느냐
조건을 보면 시간복잡도는 최대 O(N)으로 풀어야함

정렬을 해보자
    - 끝나는 시간으로 정렬을하면 최대한 많은 회의를 진행
    - 추가적으로 시작/끝 시간이 같은경우도 있으므로 시작 시간에대해서도 정렬
    -> (끝나는 시간, 시작 시간)으로 정렬하기
그리고 나서..
    - 끝 시간보다 다음 시작 시간이 크거나 같은 경우 카운트 
'''

import sys

input = sys.stdin.readline

N = int(input())
arr = sorted([tuple(map(int, input().split()))
              for _ in range(N)], key=lambda x: (x[1], x[0]))   # (끝나는 시간, 시작 시간)으로 정렬
ans = end = 0   # 이전 회의 끝나는 시간 저장하기 위함(end)
for s, e in arr:
    if s >= end:    # 현재 회의 시작시간 > 이전 회의 끝나는 시간
        ans += 1
        end = e

print(ans)
