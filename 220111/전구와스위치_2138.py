'''
>> P
N개의 스위치와 전구가 있다.
전구는 켜짐과 꺼짐 2가지 상태를 갖는다
i번 스위치를 누르면 i-1 / i / i+1 상태가 바뀐다(양 끝은 2개만)
A상태가 B상태가 되기위해 스위치 최소 몇 번 눌러야 하는가?
    - 0 : 켜짐 / 1: 꺼짐
    - 불가능한 경우 - 1 출력
>> S
왜 그리디일까 생각부터 해야해
그리디 == 최적 방법을 찾아 그걸 고수해서 문제를 풀이 한 다는 것인데 
이 문제에서 최적 해결 방법이 무엇인지 그걸 어떻게 적용할 것인지가 중요!
1차원 배열 위 전구는 본인을 포함한 양 옆에게 영향을 줘(처음과 끝은 바로 옆인 경우만)
왼쪽에서 오른쪽으로 이동하며 판단할 것이라면 왼쪽의 전구가 같은지(a=b)판단하며 그렇지 않으면 스위치 눌러가며 진행

>> 전략
최소한의 횟수로 구해야하니까 한 번 지나가면 다시 돌아오면 안돼
    -> 왼쪽에서 오른쪽으로 진행
1. 왼쪽 전구를 확인하며 toggle 여부 파악
    - a와 b가 틀린 경우 toggle 같으면 넘어가기
2. 시작 전구 파악 해야함
    - 시작은 왼쪽 전구로 판단이 안되므로 1번 경우를 2번 돌린다.

>> 코드
1. 입력 값은 받는다.
2. flip 2가지 경우(2개, 3개)인 경우 함수
def flip_two(a, b):
    global A
    A[a] = 1 - A[a]
    A[b] = 1 - A[b]
3. 왼쪽 -> 오른쪽 진행하며 toggle
for i in range(2):
    A = arr[:]
    cnt = 0
    for j in range(1, len(A)):
        if j == 0:
            if i == i and A != B:
                cnt += 1
                flip_two(j, j+1)
        elif 0 < j < len(A)-1:
            if A[j-1] != B[j-1]:
                cnt += 1
                flip_three(j-1, j, j+1)
        else:
            if A[j-1] != B[j-1]:
                flip_two(j-1, j)
    if A != B:
        return cnt
return -1
4. 결과 출력
'''
